# Всякие бинарные приколы с отрезками 
## A. Дерево отрезков на сумму
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

В этой задаче вам нужно написать обычное дерево отрезков на сумму.
### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Следующая строка содержит n чисел ai — начальное состояние массива (0≤a_i≤10^9). Далее следует описание операций. Описание каждой операции имеет следущий вид:
* 1 i v — присвоить элементу с индексом i значение v (0≤i<n, 0≤v≤10^9).
* 2 l r — вычислить сумму элементов с индексами от l до r−1 (0≤l<r≤n). 

### Выходные данные

Для каждой операции второго типа выведите соответствующую сумму.
### Пример
Входные данные
```
5 5
5 4 2 3 5
2 0 3
1 1 1
2 0 3
1 3 1
2 0 5
```

Выходные данные
```
11
8
14
```

### [Решение (ДО снизу)](A.cpp)
### [Решение (ДО сверху)](A.java)

## B. Число минимумов на отрезке
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

Теперь измените код дерева отрезков, чтобы кроме минимума на отрезке считалось также и число элементов, равных минимуму.
### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Следующая строка содержит n чисел ai — начальное состояние массива (0≤ai≤10^9). Далее следует описание операций. Описание каждой операции имеет следущий вид:

* 1 i v — присвоить элементу с индексом i значение v (0≤i<n, 0≤v≤10^9).
* 2 l r — найти минимум и число элементов, равных минимуму, среди элементов с индексами от l до r−1 (0≤l<r≤n). 

### Выходные данные

Для каждой операции второго типа выведите два числа — минимум на заданном отрезке и число элементов, равных этому минимуму.
### Пример
Входные данные
```
5 5
3 4 3 5 2
2 0 3
1 1 2
2 0 3
1 0 2
2 0 5
```

Выходные данные
```
3 2
2 1
2 3
```

### [Решение](B.cpp)

## C. Отрезок с максимальной суммой
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

В этой задаче вам нужно написать дерево отрезков для нахождения подотрезка с максимальной суммой.
### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Следующая строка содержит n чисел ai — начальное состояние массива (−109≤ai≤109). Далее следует описание операций. Описание каждой операции имеет следующий вид: i v — присвоить элементу с индексом i значения v (0≤i<n, −10^9≤v≤10^9

).
### Выходные данные

Выведите m+1 строку: максимальную сумму чисел на отрезке до всех операций и после каждой операции. Обратите внимание, что этот отрезок может быть пустым (при этом сумма на нем будет равна 0)
### Примеры
Входные данные
```
5 2
5 -4 4 3 -5
4 3
3 -1
```

Выходные данные
```
8
11
7
```

Входные данные
```
4 2
-2 -1 -5 -4
1 3
3 2
```

Выходные данные
```
0
3
3
```

### [Решение](C.java)

## D. K-я единица
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

В этой задаче вам нужно добавить в дерево отрезков операцию нахождения k-й единицы.
### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Следующая строка содержит n чисел ai — начальное состояние массива (ai∈{0,1}). Далее следует описание операций. Описание каждой операции имеет следущий вид:
* 1 i — изменить элемент с индексом i на противоположный.
* 2 k — найти k-ю единицу (единицы нумеруются с 0, гарантируется, что в массиве достаточное количество единиц). 

### Выходные данные

Для каждой операции второго типа выведите индекс соответствующей единицы (все индексы в этой задаче от 0).
### Пример
Входные данные
```
5 7
1 1 0 1 0
2 0
2 1
2 2
1 2
2 3
1 0
2 0
```

Выходные данные
```
0
1
3
3
1
```

### [Решение](D.java)

## E. Первый элемент не меньше X - 2
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

В этой задаче вам нужно добавить в дерево отрезков операцию нахождения по данным x
и l минимального индекса j, для которого j≥l и a[j]≥x.
### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Следующая строка содержит n чисел ai — начальное состояние массива (0≤ai≤109). Далее следует описание операций. Описание каждой операции имеет следущий вид:
* 1 i v — изменить элемент с индексом i на v (0≤i<n, 0≤v≤10^9).
* 2 x l — найти минимальный индекс j, для j≥l и a[j]≥x (0≤x≤109, 0≤l<n). Если такого элемента нет, выведите −1 . Индексы начинаются с 0. 

### Выходные данные

Для каждой операции второго типа выведите ответ на запрос.
### Пример
Входные данные
```
5 7
1 3 2 4 3
2 3 0
2 3 2
1 2 5
2 4 1
2 5 4
1 3 7
2 6 1
```

Выходные данные
```
1
3
2
-1
3
```

## F. Присваивание и минимум
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

Есть массив из n элементов, изначально заполненный нулями. Вам нужно написать структуру данных, которая обрабатывает два вида запросов:   
* присвоить всем элементам на отрезке от l до r−1 значение v,
* узнать минимум на отрезке от l до r−1. 

### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Далее следует описание операций. Описание каждой операции имеет следущий вид:

* 1 l r v — присвоить всем элементам на отрезке от l до r−1 значение v (0≤l<r≤n, 0≤v≤10^9).
* 2 l r — узнать минимум на отрезке от l до r−1 (0≤l<r≤n). 

### Выходные данные

Для каждой операции второго типа выведите соответствующее значение.
### Пример
Входные данные
```
5 6
1 0 3 3
2 1 2
1 1 4 4
2 1 3
2 1 4
2 3 5
```

Выходные данные
```
3
4
4
0
```

### [Решение](F.java)

## G. Присваивание, прибавление и сумма
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

Есть массив из n

элементов, изначально заполненный нулями. Вам нужно написать структуру данных, которая обрабатывает три вида запросов:

* присвоить всем элементам на отрезке от lдо r−1 значение v,
* прибавить ко всем элементам на отрезке от l до r−1 число v,
* узнать сумму на отрезке от l до r−1. 

### Входные данные

Первая строка содержит два числа n
и m (1≤n,m≤100000) — размер массива и число операций. Далее следует описание операций. Описание каждой операции имеет следущий вид:
* 1 l r v — присвоить всем элементам на отрезке от l до r−1 значение (0≤l<r≤n0≤v≤10^5).
* 2 l r v — прибавить ко всем элементам на отрезке от l до r−1 число v (0≤l<r≤n, 0≤v≤10^5).
3 l
r — узнать сумму на отрезке от l до r−1 (0≤l<r≤n). 

### Выходные данные

Для каждой операции третьего типа выведите соответствующее значение.
### Пример
Входные данные
```
5 7
1 0 3 3
2 2 4 2
3 1 3
2 1 5 1
1 0 2 2
3 0 3
3 3 5
```

Выходные данные
```
8
10
4
```

### [Решение](G.java)

## H. Землетрясения
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
1024 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

Город представляет собой последовательность из n
клеток, занумерованных числами от 0 до n−1. Изначально все клетки пустые. Далее последовательно происходят m

событий одного из двух типов:
* в клетке i строится здание с прочностью h
(если в этой клетке уже было здание, оно сносится и заменяется на новое),
* на отрезке от l до r−1 случается землятресение мощностью p, оно разрушает все здания, прочность которых не больше p.
Ваша задача — для каждого землятресения сказать, сколько зданий оно разрушит.

### Входные данные

Первая строка содержит числа n
и m — число клеток и число событий (1≤n,m≤105). Следующие m

строк содержат описание событий. Описание каждого события имеет следующий вид:

1 i h — в клетке i строится здание с прочностью h (0≤i<n, 1≤h≤109).
2 l r p — на отрезке от l до r−1 происходит землятресение с мощностью p (0≤l<r≤n, 0≤p≤109). 

### Выходные данные

Для каждого события второго типа выведите, сколько зданий было разрушено.
### Пример
Входные данные
```
5 9
1 0 3
1 2 5
2 0 4 3
1 1 4
1 2 7
2 1 3 6
1 3 8
1 4 4
2 0 5 10
```

Выходные данные
```
1
1
3
```

## I. Художник
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Итальянский художник-абстракционист Ф. Мандарино увлекся рисованием одномерных черно-белых картин. Он пытается найти оптимальное местоположение и количество черных участков картины. Для этого он проводит на прямой белые и черные отрезки, и после каждой из таких операций хочет знать количество черных отрезков на получившейся картине и их суммарную длину.

Изначально прямая — белая. Ваша задача — написать программу, которая после каждой из таких операций выводит в выходной файл интересующие художника данные.
### Входные данные

В первой строке входного файла содержится общее количество нарисованных отрезков (1≤n≤100000). В последующих n строках содержится описание операций. Каждая операция описывается строкой вида c x l, где c — цвет отрезка (W для белых отрезков, B для черных), а сам отрезок имеет вид [x;x+l), причем координаты обоих концов — целые числа, не превосходящие по модулю 500000. Длина задается положительным целым числом.
### Выходные данные

После выполнения каждой из операций необходимо вывести в выходной файл на отдельной строке количество черных отрезков на картине и их суммарную длину, разделенные одним пробелом.
### Пример
Входные данные
```
7
W 2 3
B 2 2
B 4 2
B 3 2
B 7 2
W 3 1
W 0 10
```

Выходные данные
```
0 0
1 2
1 4
1 4
2 6
3 5
0 0
```

## J. Запросы о взвешенной сумме
ограничение по времени на тест
1 second
ограничение по памяти на тест
256 megabytes
ввод
стандартный ввод
вывод
стандартный вывод

В этой задаче вам надо обрабатывать запросы о взвешенной сумме для заданного массива. Формально, пусть задан массив a[1…n]
длины n. Ваша задача уметь обрабатывать запросы двух видов:

* запрос изменения на отрезке: запрос характеризуется тремя числами l,r,d и обозначает прибавление d ко всем элементам i массива, таким что l≤i≤r,
* запрос взвешенной суммы: запрос характеризуется двумя числами l,r и обозначает вывод значения a[l]⋅1+a[l+1]⋅2+… a[r]⋅(r−l+1). 

### Входные данные

В первой строке записана пара целых чисел n,m
(1≤n,m≤105), n — длина массива, а m — количество запросов. Во второй строке записаны значения в массиве a[1],a[2],…,a[n] (−100≤a[i]≤100). Далее в m строках записаны запросы по одному в строке. Запрос первого вида записан в форме «1 l r d» (1≤l≤r≤n,−100≤d≤100), а запрос второго вида в форме «2 l r» (1≤l≤r≤n).

### Выходные данные

На каждый запрос второго типа выведите ответ в отдельной строке.
### Примеры
Входные данные
```
5 4
1 2 3 4 5
1 2 3 1
2 1 3
1 2 3 -1
2 1 5
```

Выходные данные
```
19
55
```

## K. Разреженные таблицы
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Дан массив из n
 чисел. Требуется написать программу, которая будет отвечать на запросы следующего вида: найти минимум на отрезке между u и v

включительно.
### Входные данные

В первой строке зданы три натуральных числа n, m (1⩽n⩽105, 1⩽m⩽107) и a1 (0⩽a1<16714589) — количество элементов в массиве, количество запросов и первый элемент массива соответственно. Вторая строка содержит два натуральных числа u1 и v1 (1⩽u1,v1⩽n) — первый запрос.

Для того, чтобы размер ввода был небольшой, массив и запросы генерируются.

Элементы a2,a3,…,an
задаются следующей формулой:
ai+1=(23⋅ai+21563)mod16714589.

Например, при n=10, a1=12345 получается следующий массив: a = (12345, 305498, 7048017, 11694653, 1565158, 2591019, 9471233, 570265, 13137658, 1325095).

Запросы генерируются следующим образом:
ui+1=((17⋅ui+751+ri+2i)modn)+1, vi+1=((13⋅vi+593+ri+5i)modn)+1,где ri — ответ на запрос номер i.

Обратите внимание, что ui может быть больше, чем vi.
### Выходные данные

В выходной файл выведите um, vm и rm (последний запрос и ответ на него).
### Примеры
Входные данные
```
10 8 12345
3 9
```

Выходные данные
```
5 3 1565158
```

Примечание

Можно заметить, что массивы u
, v и r

можно не сохранять в памяти полностью.

Запросы и ответы на них выглядят следующим образом:

i12345678ui3101105235vi912109123ri57026512345123451325095570265123453054981565158

Эта задача скорее всего не решается стандартными интерпретаторами Python 2 и Python 3. Используйте соответствующие компиляторы PyPy.

## L. Rectangles
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output

You are given a grid T of size N × M. Each element of this grid is a rectangle Tij, for 0 ≤ i < N and 0 ≤ j < M. Rectangle Tij is described by four integers (xij1, yij1, xij2, yij2), (xij1, yij1) and (xij2, yij2) are the coordinates of the corners of rectangle. Sides of the rectangle are parallel to the axis.

Then you are given queries. Each query consists of four integers: (r1, c1, r2, c2). Answer to this query is the area of a shape, equal to the intersection of all such rectangles Tij, that min (r1, r2) ≤ i ≤ max (r1, r2) and min (c1, c2) ≤ j ≤ max (c1, c2). There are a lot of queries, so we ask you to find the sum of answers to all queries, modulo 109 + 7.
### Input

The first line contains two integers N and M  — the dimensions of T. (1 ≤ N, M ≤ 127). The next N lines contain a description of T: in the (i + 1)-th line, the (j + 1)-th tuple of four integers xij1 yij1 xij2 yij2 is describing the rectangle Tij. It is guaranteed that |xijk|, |yijk| ≤ 106.

In the separate line, you are given four integers. The first one of them is an integer Q  — the number of queries (1 ≤ Q ≤ 5·106). The next three integers are A, B, v0 (0 ≤ A, B, v0 < 109 + 7). Using these integers, the sequence {vi} is generated, .

Then, the k-th query (the queries are one-indexed) is described by four integers: .
### Output

Print the sum of answers to all queries, modulo 109 + 7.
### Examples
Input
```
2 2
0 0 2 2 1 1 3 3
0 3 2 1 1 2 3 0
1 500000003 4 2
```

Output
```
1
```

Input
```
3 2
8 -1 -7 6 6 8 9 10
-4 -10 4 9 -3 -8 6 9
-2 -9 3 8 -5 7 7 3
5 303164476 273973578 65779139
```

Output
```
85
```

Note

In the first example, the query is of the form (1,0,0,1), so this query is about the whole grid. The intersection of all rectangles in the grid is a square with corners in points (1, 1) and (2, 2). Its area is equal to 1.

In the second example, queries are (0,1,1,1), (1,0,2,0), (0,0,2,1), (0,1,1,1), (0,1,0,0). The answer to the first query is 85, the answers to all other queries are 0.

## M. Точки и отрезки
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Дано n отрезков на числовой прямой и m точек на этой же прямой. Для каждой из данных точек определите, скольким отрезкам они принадлежат. Точка x считается принадлежащей отрезку с концами a и b, если выполняется двойное неравенство min(a, b) ≤ x ≤ max(a, b).
### Входные данные

Первая строка содержит два целых числа n (1 ≤ n ≤ 105) — число отрезков и m (1 ≤ m ≤ 105) — число точек. В следующих n строках по два целых числи ai и bi — координаты концов соответствующего отрезка. В последней строке m целых чисел — координаты точек. Все числа по абсолютной величине не превосходят 109.
### Выходные данные

В выходной файл выведите m чисел — для каждой точки количество отрезков, в которых она содержится.
### Примеры
Входные данные
```
3 2
0 5
-3 2
7 10
1 6
```

Выходные данные
```
2 0 
```

Входные данные
```
1 3
-10 10
-100 100 0
```

Выходные данные
```
0 0 1 
```

## N. Кассы
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

На одном из московских вокзалов билеты продают n касс. Каждая касса работает без перерыва определенный промежуток времени по фиксированному расписанию (одному и тому же каждый день). Требуется определить, на протяжении какого времени в течение суток работают все кассы одновременно.
### Входные данные

Сначала вводится одно целое число n (0 < n ≤ 100 000).

В каждой из следующих n строк через пробел расположены шесть целых чисел, первые три из которых обозначают время открытия кассы в часах, минутах и секундах (часы — целое число от 0 до 23, минуты и секунды — целые числа от 0 до 59), оставшиеся три — время закрытия в том же формате. Числа разделены пробелами.

Время открытия означает, что в соответствующую ему секунду касса уже работает, а время закрытия — что в соответствующую секунду касса уже не работает. Например, касса, открытая с 10 ч 30 мин 30 с до 10 ч 35 мин 30 с, ежесуточно работает 300 секунд.

Если время открытия совпадает с временем закрытия, то касса работает круглосуточно. Если первое время больше второго, то касса начинает работу до полуночи, а заканчивает — на следующий день.
### Выходные данные

Требуется вывести одно число — суммарное время за сутки (в секундах), на протяжении которого работают все n касс.
### Примеры
Входные данные
```
3
1 0 0 23 0 0
12 0 0 12 0 0
22 0 0 2 0 0
```

Выходные данные
```
7200
```

Входные данные
```
2
9 30 0 14 0 0
14 15 0 21 0 0
```

Выходные данные
```
0
```

Входные данные
```
2
14 0 0 18 0 0
10 0 0 14 0 1
```

Выходные данные
```
1
```

## O.cpp. Операционные системы
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
64 мегабайта
ввод
стандартный ввод
вывод
стандартный вывод

Васин жесткий диск состоит из M секторов. Вася последовательно устанавливал на него различные операционные системы следующим методом: он создавал новый раздел диска из последовательных секторов, начиная с сектора номер ai и до сектора bi включительно, и устанавливал на него очередную систему. При этом если очередной раздел хотя бы по одному сектору пересекается с каким-то ранее созданным разделом, то ранее созданный раздел «затирается», и операционная система, которая на него была установлена, больше не может быть загружена.

Напишите программу, которая по информации о том, какие разделы на диске создавал Вася, определит, сколько в итоге работающих операционных систем установлено и в настоящий момент работает на Васином компьютере.
### Входные данные

Сначала вводятся натуральное число M — количество секторов на жестком диске (1 ≤ M ≤ 109) и целое число N — количество разделов, которое последовательно создавал Вася (0 ≤ N ≤ 100000). Далее идут N пар чисел ai и bi, задающих номера начального и конечного секторов раздела (1 ≤ ai ≤ bi ≤ M).
### Выходные данные

Выведите одно число — количество работающих операционных систем на Васином компьютере.
### Примеры
Входные данные
```
10
3
1 3
4 7
3 4
```

Выходные данные
```
1
```

Входные данные
```
10
4
1 3
4 5
7 8
4 6
```

Выходные данные
```
3
```
