# Дискретная математика. Первый семестр

## Задача A. Бинарные отношения

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дано число _n_ и два бинарных отношения на множестве размера _n_. Для каждого из этих отно-
шений определите, являются ли они рефлексивными, антирефлексивными, симметричными, анти-
симметричными и транзитивными, а так же найдите их композицию.

### Формат входных данных

В первой строке содержится число _n_ - размер носителя (1 ≤ _n_ ≤ 100). В следующих _n_ строках
находится по _n_ чисел - описание первого отношения. Если j-е число i-й строки равно 1, то пара
(i, j) лежит в отношении, иначе эта пара не лежит в отношении. В следующих _n_ строках находится
описание второго отношения в таком же формате.

### Формат выходных данных

Для каждого из пяти свойств из условия выведите в первой строке 1, если первое отношение
обладает этим свойством, и 0 иначе. Во второй строке выведите описание второго отношения в таком
же формате.
В следующих _n_ строках выведите по _n_ чисел - композицию двух отношений в таком же формате,
что и во входных данных.

### Пример

**стандартный ввод**
```
3
0 1 0
0 0 1
1 0 0
1 1 0
0 1 1
1 0 1
```
**стандартный вывод**
```
0 1 0 1 0
1 0 0 1 0
0 1 1
1 0 1
1 1 0
```
### [Решение](A.cpp)

## Задача B. Теорема Поста

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Вам даны _n_ булевых функций, заданных таблицами истинности. Требуется проверить, является
ли заданный набор функций полным.

### Формат входных данных

В первой строке содержится одно целое число _n_ - количество функций (1 6 _n_ 6 1000).
В следующих _n_ строках содержится описание функций. Первым в строке дано число s_i - ко-
личество аргументов очередной функции (0 ≤ s_i ≤ 5). Далее дана строка a_i из 2^{s_i} символов 0 и 1,
она описывает таблицу истинности. Функция возвращает a_{ij} , если ей на вход подать представление
j в двоичной системе счисления. Порядок аргументов соответствует порядку от младших битов к
старшим.

### Формат выходных данных

В единственной строке выведите YES, если набор полон, и NO иначе.

### Пример

**стандартный ввод**
```
3
2 0111
2 0001
1 10
```
**стандартный вывод**
```
YES
```
**стандартный ввод**
```
2
2 0110
1 01
```
**стандартный вывод**
```
NO
```
### [Решение](B.cpp)

## Задача C. Схема из функциональных элементов

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дана схема из функциональных элементов в порядке топологической сортировки (то есть листья-
переменные имеют минимальные номера, а корень схемы — максимальный). Вам предстоит определить ее глубину, а также таблицу истинности для всевозможных входных данных.

### Формат входных данных

В первой строке указано натуральное число _n_ — количество вершин в схеме ( 1 ≤ _n_ ≤ 27 ). В
следующих строках описано устройство схемы.
Элементы даны в порядке от первого до _n_-го. Каждый элемент описывается либо одной (если
это переменная-лист), либо двумя строчками (если это функция). Все переменные различны. Первое
целое число _m_ в первой строчке из описания _i_-го элемента — количество входов для этого элемента
( 0 ≤ _m_ ≤ 5 ) (если элемент — переменная, то _m_ = 0). Далее в этой же строке перечислены _m_
натуральных чисел — номера элементов, значения с которых подаются на вход _i_-му.
Если _m_ > 0 , то в следующей строке дано 2*m* целых чисел a_0 ; a_1 ;...a_2m-1. Где a_j — ответ, который выдает _i_-ый элемент, если на входы подать двоичное представление числ а_j ( 0 ≤ a_j ≤ 1 ).
Более старшим разрядам _j_ соответствуют более ранние (с меньшими индексами) входы, в порядке,
написанном в предыдущей строке.

### Формат выходных данных

В первой строке выведите одно число — глубину данной схемы.
Назовем количество переменных-листьев _k_. В следующей строке выведите битовую строчку дли-
ны 2*k*, где в позиции _j_ будет число, выдаваемое схемой если на вход подается число _j_, старшим
разрядам _j_ соответствуют листы, имеющие меньшие индексы.

### Пример

**стандартный ввод**
```
5
0
0
2 1 2
1 1 0 1
0
2 3 4
1 0 0 1
```

**стандартный вывод**
```
2
01011001
```

### Замечание

Обозначим как ans_i — число, которое получается в _i_-м элементе. Тогда в данном примере значения функций, например, для 3-го элемента означают

```
ans 1 | ans 2 | ans 3
  0   |   0   |  1
  0   |   1   |  1
  1   |   0   |  0
  1   |   1   |  1
```

## Задача D. Построение схемы из функциональных элементов

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дана булева функция, заданная таблицей истинности. Постройте схему из функциональных
элементов, реализующую эту функцию в базисе ¾не¿, ¾и¿ и ¾или¿.

### Формат входных данных

В первой строке находится число _n_ - количество переменных (2 ≤ n ≤ 10). Следующие 2*n*
строк имеют следующий вид: значения переменных x1, x2, . . . , xn и значение функции при этих
переменных. Строки даны в возрастающем лексикографическом порядке значений переменных.

### Формат выходных данных

В первой строке выведите число _m_ - количество элементов в вашей схеме (включая _n_ элемен-
тов, отвечающие за исходное значение переменных). Элементы с номерами с 1 до n соответствуют
входным переменным x1, x2, . . . , xn. В следующих m − n строках выведите описание каждого но-
вого элемента в схеме. Описание элемента состоит из номера операции в этом элементе и номеров
аргументов, которые подаются на вход этому элементу.
Операция "не" имеет номер 1, "и" имеет номер 2, "или" имеет номер 3.
На вход операции "не" должно быть подан один элемент, а всем остальным два. На вход можно
подавать только элементы с меньшим номером. Результатом вычисления схемы считается значение
последнего элемента.
Разрешается использовать не более 105 элементов. Гарантируется, что существует схема, подхо-
дящее под данное ограничение.

### Пример

***стандартный ввод*** 
```
3
000 0
001 0
010 0
011 0
100 1
101 0
110 1
111 1
```
***стандартный вывод***
```
6
1 3
3 2 4
2 1 5
```
### [Решение](D.cpp)

### Замечание
Функцию из примера можно задать формулой x1 ∧ (x2 ∨ ¬x3). Ответ на пример - схема, реали-
зующая эту формулу.


## Задача E. Полином Жегалкина

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дана таблица истинности. Найдите по ней коэффициенты полинома Жегалкина.

### Формат входных данных

В первой строке содержится число _n_ — количество переменных в функции ( 1 ≤ n ≤ 10 ). Следующие 2*n* строчек имеют следующий вид: значения переменных x_1 ; x_2 ;...; x_n и значение функции при
этих переменных. Строки даны в лексикографически возрастающем порядке значений переменных.

### Формат выходных данных

Вывести 2*n* строчек в следующем формате: значения переменных, через пробел значение коэффициента полинома Жегалкина для этой записи. Порядок строк должен быть таким же, как и во
входных данных.

### Примеры

**стандартный ввод**
```
2
00 0
01 1
10 0
11 1
```

**стандартный вывод**
```
00 0
01 1
10 0
11 0
```

**стандартный ввод**
```
2
00 1
01 0
10 0
11 1
```

**стандартный вывод**
```
00 1
01 1
10 1
11 0
```

### [Решение](E.cpp)

## Задача F. Форма Хорна

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

В этой задаче задана булева функция в форме Хорна. Требуется проверить, является ли она
тождественным нулем.

### Формат входных данных

Первая строка содержит два натуральных числа _n_,_k_ — количество литералов и дизъюнктов
(скобок в формуле) соответственно ( 1 ≤ _n_; _k_ ≤ 100 ).
Следующие _k_ строк описывают дизъюнкт в следующем формате:_n_ чисел x_i ∈ { 1 ; 0 ; 1 }.
x_i = 1 — _i_-й литерал входит в дизъюнкт без отрицания.
x_i = 0 — _i_-й литерал входит в дизъюнкт с отрицанием.
x_i = 1 — _i_-й литерал не входит в дизъюнкт.

### Формат выходных данных

Выведите «YES» (без кавычек), если функция — тождественный ноль. Иначе выведите «NO» (без
кавычек).

### Примеры

**стандартный ввод**
```
3 3
1 0 -
0 1 0
-1 0 1
```
**стандартный вывод**
```
NO
```
**стандартный ввод**
```
1 2
1
0
```
**стандартный вывод**
```
YES
```
### [Решение](F.cpp)

### Замечание

В первом примере формула выглядит следующим образом: (x_1 ∨ !x_2 ) ∧ ( !x_1 ∨ x_2 ∨ !x_3 ) ∧ ( !x_2 ∨ x_3 )
Второй пример:( x_1 ) ∧ ( !x_1 )

## Задача G. К или Д?

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дано целое число _n_ и _n_ неотрицательных целых чисел. Требуется проверить, можно ли составить формулу, используя побитовые И(«&»), ИЛИ(«|»), НЕ(«»), круглые скобки(«(», «)») и
данные числа, чтобы ее результатом являлось число _s_. Если да, то выведите любую. Вместо самих
чисел в формуле должны быть их порядковые номера во входных данных. Для лучшего понимания
разберите тесты из условия.

### Формат входных данных
На первой строке содержится целое число _n_ ( 1 ≤ _n_ ≤ 5 ).
Во второй _n_ целых чисел a_i( 0 ≤ a_i ≤ 2^32-1 ).
В последней строке содержится ровно одно целое число _s_.

### Формат выходных данных

Выведите формулу, описанную выше, или «Impossible» (без кавычек), если ответа не существу-
ет. Если ответов несколько, выведите любой из них.

### Примеры

**стандартный ввод**
```
1
8
8
```
**стандартный вывод**
```
1
```

**стандартный ввод**
```
2
48 83
68
```

**стандартный вывод**
```
Impossible
```

**стандартный ввод**
```
2
20 8
8
```

**стандартный вывод**
```
2&`1
```

**стандартный ввод**
```
1
1
4294967295
```

**стандартный вывод**
```
Impossible
```
### [Решение](G.cpp)

### Замечание

Коды символов в ASCII: «&» — 38 , «|» — 124 , «» — 126 , «(» — 40 , «)» — 41.

## Задача H. Штрих Шеффера

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Известно, что с помощью штриха Шеффера (отрицание конъюнкции) можно выразить любую
булеву функцию. Таблица истинности штриха Шеффера приведена ниже:
x y x|y
0 0 1
0 1 1
1 0 1
1 1 0
Рассмотрим задачу сложения двух двоичных чисел A и B, каждое из которых состоит из _N_ бит.
Биты в числах A и B пронумерованы от 0 (младший разряд) до _N_ − 1 (старший разряд). Сумму A
и B всегда можно представить как _N_ + 1-битное число. Назовем самый старший бит суммы (бит с
номером _N_ ) битом переполнения.
Вам нужно построить булеву формулу, вычисляющую значение бита переполнения для произ-
вольных _N_ -битных чисел A и B, используя только штрих Шеффера. Формула строится по следую-
щим правилам:
• Ai  формула, равная значению i-го бита числа A.
• Bi  формула, равная значению i-го бита числа B.
• (x|y)  формула, обозначающая применение штриха Шеффера к x и y, где x и y  некоторые
формулы.
Индекс i в формулах для битов чисел A и B записывайте десятичным числом без ведущих нулей,
например, бит числа A с номером 12 должен быть записан как A12. Вокруг каждого применения
штриха Шеффера должны стоять скобки (согласно третьему правилу). Внутри формулы не должно
быть пробелов.

### Формат входных данных

Вход содержит число _N_ (1 ≤ _N_ ≤ 100).

### Формат выходных данных

Выведите формулу, вычисляющую бит переполнения суммы двух N -битных чисел A и B по
правилам, описанным в условии. Для обозначения штриха Шеффера используйте символ | (ASCII
код 124).
Размер выходного файла не должен превосходить 50N байт.

### Пример

**стандартный ввод**
```
2 
```
**стандартный вывод**
```
((((A0|B0)|(A0|B0))|((A1|A1)|(B1|B1)))|(A1|B1))
```
### [Решение](H.cpp)