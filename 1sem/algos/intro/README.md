# Лабораторная 1. Первая половина тем

## A. Простая сортировка
ограничение по времени на тест: 2 секунды
ограничение по памяти на тест: 64 мегабайта
ввод: стандартный ввод
вывод: стандартный вывод

В этой задаче вам нужно реализовать любую из пройденных сортировок, работающих за время O(nlogn)

. Использовать встроенные в язык сортировки и структуры данных запрещается.

Дан массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

### Входные данные
В первой строке содержится число n
(1⩽n⩽100000) — количество элементов в массиве. Во второй строке находятся n целых чисел, по модулю не превосходящих 109.

### Выходные данные
Выведите этот же массив в порядке неубывания.

### Пример

**стандартный ввод**
```
10
1 8 2 1 4 7 3 2 3 6
```
**стандартный выввод**
```
1 1 2 2 3 3 4 6 7 8 
```

### [Решение](A.cpp)

## B. Сортировка подсчетом
ограничение по времени на тест: 1 секунда
ограничение по памяти на тест: 64 мегабайта
ввод: стандартный ввод
вывод: стандартный вывод

А в этой задаче вам нужно реализовать сортировку подсчетом. Использовать другие сортировки запрещается.

Дан массив из n элементов, которые принимают целые значения от 0 до 100. Отсортируйте этот массив в порядке неубывания элементов.

### Входные данные
В первой строке содержится число n (1 ≤ n ≤ 200 000) — количество элементов в массиве. Во второй строке находятся n целых чисел, от 0 до 100 каждое.

### Выходные данные
Выведите отсортированный массив.

### Пример

**стандартный ввод**
```
5
7 3 4 2 5
```
**стандартный вывод**

```
2 3 4 5 7 
```

### [Решение](B.cpp)

## C. Количество инверсий
ограничение по времени на тест: 5 секунд
ограничение по памяти на тест: 256 мегабайт
ввод: стандартный ввод
вывод: станнартный вывод

Напишите программу, которая для заданного массива A=⟨a1,a2,…,an⟩
находит количество пар (i,j) таких, что i<j и ai>aj.

### Входные данные
Первая строка входного файла содержит натуральное число n
(1≤n≤500000) — количество элементов массива. Вторая строка содержит n попарно различных элементов массива A (0≤ai≤106).

### Выходные данные
В выходной файл выведите одно число — ответ на задачу.

### Пример
Входные данные
Скопировать

**стандартный ввод**
```
4
1 2 4 5
```
**стандартный вывод**
```
0
```
**стандартный ввод**
```
4
5 4 2 1
```
**стандартный вывод**
```
6
```

### [Решение](C.cpp)

# E. Хип ли?
ограничение по времени на тест: 1 секунда
ограничение по памяти на тест: 256 мегабайт
ввод: стандартный ввод
вывод: стандартный вывод

Структуру данных Heap можно реализовать на основе массива.

Для этого должно выполнятся основное свойство Heap'a, которое заключается в следующем. Для каждого 1⩽i⩽n

выполняются следующие условия:

    Если 2i⩽n

, то a[i]⩽a[2i]
Если 2i+1⩽n
, то a[i]⩽a[2i+1]

Дан массив целых чисел. Определите является ли он Heap'ом.

### Входные данные
Первая строка входного файла содержит целое число n
(1⩽n⩽105). Вторая строка содержит n целых чисел по модулю не превосходящих 2⋅109.

### Выходные данные
Выведите «YES», если массив является Heap'ом и «NO» в противном случае.
### Пример
Входные данные
Скопировать
**стандартный ввод**
```
5
1 0 1 2 0
```
**стандартный вывод**
```
NO
```

**стандартный ввод**
```
5
1 3 2 5 4
```

**стандартный ввод**
```
YES
```

### [Решение](E.cpp)

## F. Хипуй!
ограничение по времени на тест
3 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:

    Insert(X) — добавить в Heap число X;
    Extract — достать из Heap наибольшее число (удалив его при этом). 

Эту задачу нужно решить без использования встроенных структур данных для поиска максимального числа.
### Входные данные

Во входном файле записано количество команд n (1 ≤ n ≤ 100 000), потом последовательность из n команд, каждая в своей строке.

Каждая команда имеет такой формат: "0 <число>" или "1", что означает соответственно операции Insert(<число>) и Extract. Добавляемые числа находятся в интервале от 1 до 107 включительно.

Гарантируется, что при выполнении команды Extract в структуре находится по крайней мере один элемент.
### Выходные данные

В выходной файл для каждой команды извлечения необходимо вывести число, полученное при выполнении команды Extract.
### Пример
Входные данные
```
7
0 100
0 10
1
0 5
0 30
0 50
1
```

Выходные данные
```
100
50
```

### [Решение](F.cpp)

## G. Префиксные суммы
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Дан массив целых чисел. Необходимо для каждого из m
запросов выводить сумму на отрезке [l,r]

.
### Входные данные

В первой строке заданы числа n
и m — размер массива и количество запросов (1≤n,m≤106). Во второй строке n целых чисел ai (−109≤ai≤109) — элементы массива a. Далее следуют m строк вида li ri, для которых нужно посчитать сумму на отрезке [li,ri]

.
### Выходные данные

Для каждого запроса выведите на отдельной строке сумму на отрезке [li,ri]

.
### Пример
Входные данные
```
6 4
1 4 3 7 10 8
1 3
2 5
3 6
1 6
```

Выходные данные
```
8
24
28
33
```

### [Решение](G.cpp)

## H. Скобки
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Требуется определить, является ли правильной данная последовательность круглых, квадратных и фигурных скобок.
### Входные данные

В единственной строке входного файла записано подряд N скобок (1 ≤ N ≤ 105).
### Выходные данные

В выходной файл вывести «YES», если данная последовательность является правильной, и «NO» в противном случае.
### Примеры
Входные данные
```
()
```

Выходные данные
```
YES
```

Входные данные
```
([]){}
```

Выходные данные
```
YES
```

Входные данные
```
[]([)]
```

Выходные данные
```
NO
```

Примечание

Скобочная последовательность называется правильной, если ее можно получить из какого-либо математического выражения вычеркиванием всех символов, кроме скобок.

Формальное определение правильной скобочной последовательности таково:

    Пустая последовательность является правильной.
    Если A — правильная скобочная последовательность, то (A), [A] и {A} — правильные скобочные последовательности.
    Если A и B — правильные скобочные последовательности, то AB — правильная скобочная последовательность. 


### [Решение](H.cpp)

## I. Сортировка вагонов
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

К тупику со стороны пути 1 (см. рисунок) подъехал поезд. Разрешается отцепить от поезда один или сразу несколько первых вагонов и завезти их в тупик (при желании, можно даже завезти в тупик сразу весь поезд). После этого часть из этих вагонов вывезти в сторону пути 2. После этого можно завезти в тупик еще несколько вагонов и снова часть оказавшихся вагонов вывезти в сторону пути 2. И так далее (так, что каждый вагон может лишь один раз заехать с пути 1 в тупик, а затем один раз выехать из тупика на путь 2). Заезжать в тупик с пути 2 или выезжать из тупика на путь 1 запрещается. Нельзя с пути 1 попасть на путь 2, не заезжая в тупик.

Известно, в каком порядке изначально идут вагоны поезда. Требуется с помощью указанных операций сделать так, чтобы вагоны поезда шли по порядку (сначала первый, потом второй и т.д., считая от головы поезда, едущего по пути 2 в сторону от тупика).
### Входные данные

Вводится число N — количество вагонов в поезде (1 ≤ N ≤ 2000). Дальше идут номера вагонов в порядке от головы поезда, едущего по пути 1 в сторону тупика. Вагоны пронумерованы натуральными числами от 1 до N, каждое из которых встречается ровно один раз.
### Выходные данные

Если сделать так, чтобы вагоны шли в порядке от 1 до N, считая от головы поезда, когда поезд поедет по пути 2 из тупика, можно, выведите действия, которые нужно проделать с поездом. Каждое действие описывается двумя числами: типом и количеством вагонов:

    если нужно завезти с пути 1 в тупик K вагонов, должно быть выведено сначала число 1, а затем — число K(K ≥ 1),
    если нужно вывезти из тупика на путь 2 K вагонов, должно быть выведено сначала число 2, а затем — число K(K ≥ 1). 

Если возможно несколько последовательностей действий, приводящих к нужному результату, выведите любую из них.

Если выстроить вагоны по порядку невозможно, выведите одно число 0.
### Примеры
Входные данные
```
3
3 2 1
```

Выходные данные
```
1 1
1 1
1 1
2 1
2 1
2 1
```

Входные данные
```
4
4 1 3 2
```

Выходные данные
```
1 1
1 1
2 1
1 1
1 1
2 1
2 1
2 1
```

Входные данные
```
3
2 3 1
```

Выходные данные
```
0
```

### [Решение](I.cpp)

## J. Обход файлов
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Сережа уже взрослый и вместо игр он гуляет по директориям на своем компьютере. Например, сегодня он посетил /Documents/programming/cheats/ и /Documents/programming/2020/solutions/K.txt.

Поскольку в последнее время он делает это довольно часто, ему хочется иметь удобное для просмотра представление директорий, чтобы можно было видеть, какие директории в какие вложены. Для этого он просит вашей помощи.

Вам требуется по списку директорий вывести их перечисление в алфавитном порядке, где каждая вложенная директория выведена с отступом на два пробела больше, чем ее родительская директория.
### Входные данные

В первой строке дано число n
 —количество директорий на компьюторе Сережи (1⩽n⩽105

).

В слудующих n

строках по одному в строке заданы абсолютные пути ко всем директориям, каждый абсоютный путь — это последовательность вложенных папок, начиная с корневой, разделенная символами </>.

Гарантируется, что первая директория во всех путях одинаковая и имеет непустое имя. Имена всех директорий состоят из маленьких латинских букв и имеют длину не более 10

. Гарантируется, что если директория выведена, то выведены и все, в которые она вложена.
### Выходные данные

Выведите перечисление всех директорий, в котором все директории внутри одной упорядочены по алфавиту, вложенные идут сразу после родительской и имеют отступ на два пробела больше, чем у нее.
### Примеры
Входные данные
```
6
root/a
root/a/b
root/c/x
root/a/b/c
root
root/c
```

Выходные данные
```
root
  a
    b
      c
  c
    x
```

Входные данные
```
4
a/b/c/d
a/b
a/b/c
a
```

Выходные данные
```
a
  b
    c
      d
```


### [Решение](J.py)

## K. Минимум в очереди
ограничение по времени на тест
4.0 с
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Изначально очередь пуста. Приходят запросы

    + x добавить в конец очереди элемент x
    - удалить из начала очереди элемент 

Гарантируется, что вторая операция не пытается удалить элемент из пустой очереди. После каждой операции нужно выводить минимум в очереди после него.

Ограничение по времени выставлено так, чтобы решение с std::set не проходило.
### Входные данные

В первой строке записано единственное число q (1 ≤ q ≤ 106) — количество запросов. В следующих q строках записаны сами запросы в описанном выше формате. Все числа во входном файле целые, положительные и не превышают 109.
### Выходные данные

Для каждого запроса выведите единственное число — минимум в очереди после выполнения этого запроса. Если после запроса очередь пуста, выводите -1.
### Примеры
Входные данные
```
10
+ 1
+ 2
+ 3
+ 4
+ 5
-
-
-
-
-
```

Выходные данные
```
1
1
1
1
1
2
3
4
5
-1
```


### [Решение](K.cpp)

## L. Быстрый поиск в массиве
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
512 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Дан массив из n
целых чисел. Все числа от −109 до 109

.

Нужно уметь отвечать на запросы вида «Cколько чисел имеют значения от l
до r

»?
### Входные данные

Число n
(1≤n≤105). Далее n

целых чисел.

Затем число запросов k
(1≤k≤105

).

Далее k
пар чисел l,r (−109≤l≤r≤109

) — собственно запросы.
### Выходные данные

Выведите k

чисел — ответы на запросы.
### Пример
Входные данные
```
5
10 1 10 3 4
4
1 10
2 9
3 4
2 2
```

Выходные данные
```
5 2 2 0 
```


### [Решение](L.py)

## M. Приближенный двоичный поиск
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Даны два массива. Первый массив отсортирован по неубыванию, второй массив содержит запросы — целые числа.

Для каждого запроса выведите число из первого массива наиболее близкое (то есть с минимальным модулем разности) к числу в этом запросе . Если таких несколько, выведите меньшее из них.
### Входные данные

В первой строке входных данных содержатся числа n и k (0 < n, k ≤ 105). Во второй строке задаются n чисел первого массива, отсортированного по неубыванию, а в третьей строке — k чисел второго массива. Каждое число в обоих массивах по модулю не превосходит 2·109 .
### Выходные данные

Для каждого из k чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.
### Пример
Входные данные
```
5 5
1 3 5 7 9
2 4 8 1 6
```

Выходные данные
```
1
3
7
1
5
```


### [Решение](M.cpp)

## N. Очень Легкая Задача
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Сегодня утром жюри решило добавить в вариант олимпиады еще одну, Очень Легкую Задачу. Ответственный секретарь Оргкомитета напечатал ее условие в одном экземпляре, и теперь ему нужно до начала олимпиады успеть сделать еще n копий. В его распоряжении имеются два ксерокса, один из которых копирует лист за x секунд, а другой — за y. (Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.) Помогите ему выяснить, какое минимальное время для этого потребуется.
### Входные данные

На вход программы поступают три натуральных числа n, x и y, разделенные пробелом (1 ≤ n ≤ 2·108, 1 ≤ x, y ≤ 10).
### Выходные данные

Выведите одно число — минимальное время в секундах, необходимое для получения n копий.
### Примеры
Входные данные
```
4 1 1
```

Выходные данные
```
3
```

Входные данные
```
5 1 2
```

Выходные данные
```
4
```

### [Решение](N.cpp)

## O. Квадратный корень и квадратный квадрат
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Найдите такое число x
, что x2+x−−√=C

, с точностью не менее 6 знаков после точки.
### Входные данные

В единственной строке содержится вещественное число 1.0≤C≤1010

.
### Выходные данные

Выведите одно число — искомый x

.
### Примеры
Входные данные
```
2.0000000000
```

Выходные данные
```
1.0
```

Входные данные
```
18.0000000000
```

Выходные данные
```
4.0
```


### [Решение](O.cpp)

## P. K-best
ограничение по времени на тест
2 секунды
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

У Демьяны есть n
драгоценностей. Каждая из драгоценностей имеет ценность vi и вес wi. С тех пор, как её мужа Джонни уволили в связи с последним финансовым кризисом, Демьяна решила продать несколько драгоценностей. Для себя она решила оставить лишь k лучших. Лучших в смысле максимизации достаточно специфического выражения: пусть она оставила для себя драгоценности номер i1,i2,…,ik

, тогда максимальной должна быть величина

∑j=1kvij∑j=1kwij

Помогите Демьяне выбрать k

драгоценностей требуемым образом.

На первой строке n
и k (1≤k≤n≤100000

).
### Входные данные

Следующие n
строк содержат пары целых чисел vi, wi (0≤vi≤106,1≤wi≤106, сумма всех vi не превосходит 107, сумма всех wi также не превосходит 107

).
### Выходные данные

Выведите k
различных чисел от 1 до n

 — номера драгоценностей. Драгоценности нумеруются в том порядке, в котором перечислены во входных данных. Если есть несколько оптимальных ответов, выведите любой.
### Примеры
Входные данные
```
3 2
1 1
1 2
1 3
```

Выходные данные
```
1
2
```

## Q. Разделение массива
ограничение по времени на тест
1 секунда
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Дан массив из n
положительных целых чисел. Нужно разбить его на k

отрезков так, чтобы максимальная сумма на отрезке была минимально возможной.
### Входные данные

Первая строка содержит целые числа n
и k (1≤k≤n≤105). Вторая строка содержит элементы массива ai (1≤ai≤109

).
### Выходные данные

Выведите одно число — минимально возможную максимальную сумму на отрезке.
### Пример
Входные данные
```
10 4
1 3 2 4 10 8 4 2 5 3
```

Выходные данные
```
12
```

## R. K-я сумма
ограничение по времени на тест
2.0 с
ограничение по памяти на тест
256 мегабайт
ввод
стандартный ввод
вывод
стандартный вывод

Есть два массива a
и b, каждый из которых состоит из n чисел. Для каждой пары чисел (i,j):1≤i,j≤n выпишем сумму чисел ai+bj. Найдите в полученном множестве сумм k

-ю по возрастанию.
### Входные данные

Первая строка содержит целые числа n
и k (1≤n≤105, 1≤k≤n2). Вторая строка содержит элементы массива a, третья строка содержит элементы массива b. Все элементы массивов — целые положительные числа, не больше 109

.
### Выходные данные

Выведите одно число — искомая k

-я сумма.
### Пример
Входные данные
```
5 10
4 2 6 4 8
7 3 1 9 5
```

Выходные данные
```
9
```
